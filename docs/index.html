<!DOCTYPE html>
<HTML>
<HEAD>
   <TITLE>DaveCloud Mail and Backup</TITLE>
   <link rel="stylesheet" type="text/css" href="style.css">
</HEAD>
<BODY>
<div class=toc>
<UL>
<LI><A href=index.html>[home]</A>
<p>
<li><a href="#pkgs">Packages</a>
<li><a href="#hosts">Hosts</a>
<li><a href="#vars">Variables</a>
<li><a href="#first">First Login Playbook</a>
<li><a href="#play">Site Setup Playbook</a>
<li><a href="#reboot">Rebooting</a>
<li>These Ansible scripts set up mail and web service, with regular
backups to a second machine.  My three goals were:
</UL>
</div>

<div class=main>
<H1>DaveCloud Mail, Web, and Backup</H1>

<p>These Ansible scripts set up mail and web service, with regular
backups to a second machine.  My three goals were:
<ol>
<li>Mail and web for one or more domains, 
<li>Built securely with modern packages, and proper backups,
<li>A ground-up understanding of what is on the machine and why.
</ol>

<p>Along the way, I also developed a pretty good knowledge of Ansible.
The <em>what</em> and <em>why</em> are documented in these pages, as a
starting point for your own choices.  If a ground-up understanding is
not important to you, a push-button mail server
like <a href="https://github.com/modoboa/modoboa">Modoboa</a>,
<a href="https://mailinabox.email/">mail-in-a-box</a>, or
<a href="https://github.com/progmaticltd/homebox">homebox</a> is a
fine solution.</p>

<p>I don't include many extra packages, which means fewer things to
understand, a smaller attack surface, and lower machine requirements.
For example, we manage the dozen or so virtual mail accounts using
SQLite rather than a full MySQL install.  This simplifies database
security to just file permissions.</p>

<p>Typically, mail and web are on a machine in the cloud (AWS, Linode,
DigitalOcean, etc.) while backups are run by a machine that you have
physical control over (old PC or Raspberry Pi in your basement).  I
have run the total setup with a $5/mo cloud machine for mail/web and a
Raspberry Pi Zero as the Bacula director.</p>

<p>I hope you find this useful as a starting point for
reaching <em>your</em> goals.</p>


<p>TO DO LIST
<UL>
<LI>Configure RSPAMD with postfix.
<LI>Extend SQL to allow reject mail to relay@ (login only) sendonly support to the SQL and recipient-access
<LI>Deploy DNS on live machine
<LI>Configure DKIM and automate key rotation with postfix and DNS.
<LI>Configure DMARC entry in the DNS.
<LI>Cut over on actual sites.
<LI>Thunderbird has trouble autoconfiging on virtual domains.   Must set port and passwd type manually.   Also the autoconfiging attempts will trip a fail2ban rule, locking you out.
<LI>Look at apticron or unattended-upgrades for keeping patched.
<LI>Nullclient masqarade a .local domain to the main domain?
<LI>Null client with cert based auth
<LI>Ipset with a variety of Class As to block port 22 and quiet down
the logs.
<LI>Strip extra headers on outgoing mail
</UL>

<p>Can run dpkg-reconfigure on packages

<!-- ============================== -->
<H2 class=rule>
<A NAME=pkgs></A>Packages</H2>

<p>These playbooks assume Debian 10.  I haven't tested with other
distros, but there are likely to be some changes to file locations or
slightly different package lists.  In most cases, I used the
Ansible <code>package:</code> module rather than <code>apt:</code> for
installing things, so it works with package managers like emerge or
yum.
<a href="ansible.html">Why Ansible?</a>
<a href="debian.html">Why Debian?</a></p>

<p>The playbooks cover the following areas: 

<ul>
<li><a href="ssh.html">SSH</a>
<li><a href="firewall.html">Firewall</a>
<li><a href="apache.html">Web Server</a>
<li><a href="mail.html">Mail Server and Clients</a>
<li><a href="encrypt.html">Encryption</a>
<li><a href="dns.html">DNS Configuration</a>
<li><a href="backup.html">Backup</a>
</ul>





<!-- ============================== -->
<H2 class=rule>
<A NAME=hosts></A>Hosts</H2>

<p>The <code>hosts</code> file describes the machines that you are
managing, and organizes them into groups.  The playbooks then describe
tasks and roles that apply to the machines in each group.  We use two
groups: <code>cloud</code> and <code>backup-server</code>.</p>

<p>The machines are listed by fully qualified domain name (FQDN) and
IP address, so the machine does not need to show up in DNS yet.
Ansible uses the <code>ansible_host</code> variable to connect, and
sets the <code>inventory_hostname</code> variable to the FQDN for use
in the scripts.</p>

<PRE class=code>
[cloud]
# mail and webserver, needs a public IP address from a business class
# ISP connection or VPS provider like AWS, Linode, or DigitalOcean
example.com		ansible_host=1.2.3.4

[backup-server]
# connects to other machines to fetch and store backups, best if you
# have physical control of the machine.  It does not need a public IP
# and can be behind a residential ISP connection.
guardian.example.com	ansible_host=5.6.7.8
</PRE>


<!-- ============================== -->
<H2 class=rule>
<A NAME=vars></A>Variables</H2>

<p>The ansible variables are located under the <code>group_vars</code>
directory.  Right now we are just using a single <code>all</code> set, but
you can get fancier if you have multiple machines and want to track
more variations.</p>

<p>Private information like passwords and such are stored encrypted in a
<a href="https://docs.ansible.com/ansible/latest/user_guide/vault.html">vault
file</a>.  Ansible asks for the password to this when
the <code>--ask-vault-pass</code> flag is given.  You can edit and
manipulate it from the command line with:</p>
<PRE class=code>
ansible-vault edit foo.yml 		# run EDITOR on file

ansible-vault rekey foo.yml 		# change password on file
ansible-vault encrypt foo.yml 		# encrypt plain file
ansible-vault decrypt foo.yml 		# convert encrypted to plain file
</PRE>

<p>To make it easier to keep track of everything, the cleartext vars
file has a stub for each value hidden in the vault.  The stub simply
references a similar variable with a "vault_" prefix that is stored in
the encrypted vault file.  For example, a password might show up like
the following in the cleartext file.</p>

<PRE class=code>
  - email: "somebody@foobar.com"
    pw: "{{vault_mbox_someone_pw}}"
</PRE>


<!-- ============================== -->
<H2 class=rule>
<A NAME=first></A>First Login Playbook</H2>

<p>The first thing to do after provisioning a machine is run the
playbook with the 'first' tag to lock down SSH.  This should be the
only time a password based login is used with the machine.  You need
"sshpass" installed locally because the remote machine does not yet
have any keys installed.  After this, remote password login is
disabled and everything uses ssh keys.  It is also a good idea to
change the root password manually because the original passed through
the Linode UI.  The lowercase <code>-k</code> flag is a shorthand
for <code>--ask-pass</code></p>

<PRE class=code>
$ ansible-playbook -k --ask-vault-pass -i hosts first.yml --extra-vars "target=guardian"
</PRE>

<PRE class=code>
$ ansible-playbook --ask-vault-pass -i hosts site.yml --limit my-new-machine --tags first
</PRE>

<p><b>UPDATE</b> now we are preinstalling a public key for needs to be
in openssh form; to convert keys from putty, install the putty-utils
package and do:</p>


<p>The public key needs to be in openssh form; to convert keys from
putty, install the putty-utils package and do:</p>

<PRE class=code>
$ puttygen foobar.ppk -O public-openssh -o foobar.pub
$ puttygen foobar.ppk -O private-openssh -o foobar.key
</PRE>

<p>When you rebuild a machine, the host key changes and SSH freaks out
with ominous messages about man in the middle attacks.  You can
selectively make ssh forget the key for the name and IP using commands
like below.</p>

<PRE class=code>
$ ssh-keygen -f "/home/foo/.ssh/known_hosts" -R "example.com"
$ ssh-keygen -f "/home/foo/.ssh/known_hosts" -R "11.22.33.44"
</PRE>



<!-- ============================== -->
<H2 class=rule>
<A NAME=play></A>Site Setup Playbook</H2>

<p>The <code>site.yml</code> playbook configures machines for the
services described below.  Ansible playbooks are is meant to be
idempotent, which means that they are supposed to leave a machine in a
given state, no matter how many times you run it or what state it was
in before.</p>

<p>The command below runs the playbook on all machines in the 'hosts'
inventory file.  It runs as the <code>deploy</code> user and asks passwords
for sudo on the deploy user and the vault password.  Both are the
stpbuild passwords.  The uppercase <code>-K</code> flag is a shorthand
for <code>--ask-become-pass</code></p>

<PRE class=code>
$ ansible-playbook -K --ask-vault-pass -i hosts site.yml
</PRE>

<p>There is another <a href="snapshot.html">snapshot.yml</a> playbook
that copies back certain data like the letsencrypt keys so that they
can be transfered over when wiping or migrating a machine.  This
playbook is run in the same way as <code>site.yml</code>.</p>


<!-- ============================== -->
<H2 class=rule>
<A NAME=reboot></A>Rebooting</H2>

<p>The machine should boot clean and everything will come up except
mail.  Because the mail spool is encrypted, you must log in,
run <code>/etc/postfix/mailboot</code> to enter the EncFS password.
This will mount the cleartext directories and start postfix.</p>

</div>
</BODY>
</HTML>
