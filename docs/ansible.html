<!DOCTYPE html>
<html lang="en">
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">

<title>Why Ansible?</title>
<link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>
<div class=toc>
<UL>
<LI><A href=index.html>[home]</A>
</UL>
</div>

<div class=main>
<H1>Why Ansible?</H1>

<p>Back in the day, you generally configured a new machine by editing
an endless series of config files while sitting at the console, or
once the OS was installed, remotely via telnet or ssh.  A few hours or
days later, the machine was declared good and left alone.</p>

<p>If you did it a few times, you could copy config files from other
machines to use as starting points.  If did it many times, you might
put together basic shell scripts to automate some things.  Really big
sites could leverage enterprise deployment tools.  But if it had been
a while, as was always the case with me, you forgot it all and had to
relearn, iterating as you missed things.  Over time, machines
accumulated undocumented tweaks and extra packages.</p>

<p>This is no way to run a railroad.  In software development, we no
longer call the C compiler manually.  Instead we describe the desired
state - source files, object files, executables - and let a tool
like <code>make</code> or <code>msbuild</code> figure out which
actions to use to place the code into that state.</p>

<p>Ansible is essentially <code>make</code> for machines, and the
playbooks and roles are the <code>Makefiles</code>.  These describe a
series of "idempotent" tasks - they leave the machine in the same
state no matter how many times you run them.  For example, a config
file needs a line "foo=bar".  If missing, "foo=bar" is added.  If
"foo=zap" is present, it is changed to "foo=bar".  If it already has
the correct value, it is left alone.  At the end, that config file
will have one copy of the value and it will be "foo=bar".</p>

<p>Other tasks might say that a package should be present or absent.
The package will be either installed or uninstalled as needed to match
the declared state.  The end result is that you will have a machine in
a known state after running a series of Ansible tasks against it.</p>

<p>This is a wonderful way to run a railroad.  You can describe in
great detail the exact state of a machine, put it under source
control, and reproduce it as needed.  Ansible works remotely over ssh
and can operate in parallel on lists of hosts, so you can configure or
reproduce whole networks of machines.</p>

<div class=copyright>
<p>Copyright &copy; 2020 David Loffredo, licensed under
<a rel="license" href="https://creativecommons.org/licenses/by/4.0/">
CC BY 4.0</a>.
</p>
</div>
</div>
</body>
</html>

