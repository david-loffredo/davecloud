<!DOCTYPE html>
<html lang="en">
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">

<title>Encryption</title>
<link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>
<div class=toc>
<UL>
<LI><A href=index.html>[home]</A>
<p>
<li><a href="#certbot">Certbot / LetsEncrypt</a>
<li><a href="#certbot_vars">Certbot Variables</a>
<li><a href="#cryptdir">Disk Encryption</a>
<li><a href="#cryptdir_vars">Disk Encryption Variables</a>
<li><a href="#why">Why These Packages?</a>
</UL>
</UL>
</div>

<div class=main>
<H1><A NAME=overview></A>Encryption</H1>

<p>When talking about encryption, people usually distinguish between
<a href="https://en.wikipedia.org/wiki/Data_in_transit">data in
transit</a> and
<a href="https://en.wikipedia.org/wiki/Data_at_rest">data at rest</a>.
To protect data in transit, we encrypt communication links for mail
(STARTTLS and IMAPS) and web (HTTPS).  To give the other party
confidence that we are who we claim to be, we identify ourself using
certificates issued by <a href="#certbot">Certbot /
LetsEncrypt</a>.</p>

<p>To protect data at rest, we place sensitive data like the mail
spool, DKIM keys, and mail user database into
a <a href="#cryptdir">central encrypted directory</a>.  When the
machine is rebooted, everything starts normally except mail.  We must
ssh in and run the <code>mailboot</code> script and type in the
encryption password to unlock the directories and start the mail
daemon.  Any incoming mail should remain queued by the sending system
until the mail daemon is up again.</p>

<p>Keeping the communication secure is an ongoing effort, as various
protocols are strengthened and deprecated in response to ever more
clever attacks.  Tools
like <a href="https://testssl.sh/">testssl.sh</a> and sites like
<a href="https://www.immuniweb.com/">immuniweb.com</a> are useful for
periodically scanning for new vulnerabilities.  The 
<a href="https://github.com/jtesta/ssh-audit">ssh-audit</a> script
looks for weaknesses in the <a href="ssh.html">SSH setup</a>
and <a href="https://github.com/CISOfy/lynis">Lynis</a> test many
different aspects of a system.</p>


<!-- ============================== -->
<H2 class=rule>
<A NAME=certbot></A>Certbot / LetsEncrypt</H2>

<p><b>ROLE</b> apache, certbot.yml

<p>We use certbot to acquire LetsEncrypt SSL certificates.  We
generate one certificate per root domain.  Each certificate matches
all of the aliases that we use for that domain (www., mail., etc),
which should make it easier to move domains to separate machines if
needed.  Since we manage our own DNS, we could use the DNS challenge
and get a wildcard cert, but that is not really recommended unless you
are creating machines dynamically.</p>

<p>The <code>/etc/letsencrypt</code> directory holds a history of all
past keys under the <code>archive</code> directory and symlinks to the
current one under the <code>live</code> directory.  These are mode 700
so only apps that run as root can see them.  This works for apache,
postfix and dovecot, but if a non-root app needs access, you might
want to create a ssl-cert group and change it to mode 750.</p>

<p>Below is an example of certs for mydomain.net and foobar.com
domains.  Note the symlinks in the live directory.  When archiving the
letsencrypt directory, it is important to use a method that preserves
these symlinks or else certbot may not renew
properly.  <a href="backup.html">Bacula</a> preserves the links and
the <a href="snapshot.html">snapshot</a> action makes a compressed tar
file of this directory when preserving the config.</p>

<PRE class=code>
root@localhost:/etc/letsencrypt# ls -l
total 40
drwxr-xr-x 3 root root 4096 Dec  2 23:08 accounts
drwx------ 4 root root 4096 Dec  2 23:08 archive
-rw-r--r-- 1 root root  121 May 26  2018 cli.ini
drwxr-xr-x 2 root root 4096 Dec  2 23:08 csr
drwx------ 2 root root 4096 Dec  2 23:08 keys
drwx------ 4 root root 4096 Dec  2 23:08 live
-rw-r--r-- 1 root root 1618 Dec  2 19:42 options-ssl-apache.conf
drwxr-xr-x 2 root root 4096 Dec  2 23:08 renewal
drwxr-xr-x 5 root root 4096 Dec  2 23:08 renewal-hooks
-rwxr-xr-x 1 root root 1923 Dec  2 19:42 testcertnames

root@localhost:/etc/letsencrypt# ls -l live/*
live/mydomain.net:
total 4
lrwxrwxrwx 1 root root  37 Dec  2 19:42 cert.pem -> ../../archive/mydomain.net/cert1.pem
lrwxrwxrwx 1 root root  38 Dec  2 19:42 chain.pem -> ../../archive/mydomain.net/chain1.pem
lrwxrwxrwx 1 root root  42 Dec  2 19:42 fullchain.pem -> ../../archive/mydomain.net/fullchain1.pem
lrwxrwxrwx 1 root root  40 Dec  2 19:42 privkey.pem -> ../../archive/mydomain.net/privkey1.pem
-rw-r--r-- 1 root root 692 Dec  2 19:42 README

live/foobar.com:
total 4
lrwxrwxrwx 1 root root  39 Dec  2 19:42 cert.pem -> ../../archive/foobar.com/cert1.pem
lrwxrwxrwx 1 root root  40 Dec  2 19:42 chain.pem -> ../../archive/foobar.com/chain1.pem
lrwxrwxrwx 1 root root  44 Dec  2 19:42 fullchain.pem -> ../../archive/foobar.com/fullchain1.pem
lrwxrwxrwx 1 root root  42 Dec  2 19:42 privkey.pem -> ../../archive/foobar.com/privkey1.pem
-rw-r--r-- 1 root root 692 Dec  2 19:42 README
</PRE>

<p>Certificate renewal is done using cron.  Services that depend on
them are stopped and started by adding small shell scripts to
the <code>pre</code> and <code>post</code> directories
under <code>renewal-hooks</code>.  Some can just be bounced by adding
a reload or restart action to the <code>post</code> directory.</p>

<!-- ============================== -->
<H2 class=rule>
<A NAME=certbot_vars></A>Certbot Variables</H2>

<p>We generate a cert for each host <code>name</code> in
the <code>web_vhost</code> in the group_vars, and make it also support
each of the <code>aliases</code> for that host.  So in the example
below, we would have two certs.  The first is for "example.com",
"www.example.com", and "mail.example.com".  The second is for
"foobar.com" and "www.foobar.com".</p>

<PRE class=code>
web_vhosts:
  - name: "example.com"
    aliases:
      - www.example.com
      - mail.example.com
  - name: foobar.com
    aliases:
      - www.foobar.com
</PRE>

<!-- ============================== -->
<H2 class=rule>
<A NAME=cryptdir></A>Disk Encryption</H2>

<p><b>ROLE</b> cryptdir

<p>We create one directory for all data that should be encrypted at
rest.  The encryption technology can be LUKS, EncFS, or none.  With
none, this role does no encryption.</p>

<p>LUKS uses a separate disk partition that is be encrypted at the
block level, then mounted as cleartext block device through the
mapper.  The cleartext block device is then given a normal Ext4
filesystem and mounted normally.</p>

<p>With EncFS, a separate directory containing individually encrypted
files is mounted loopback as cleartext through FUSE.  It is outdated
but simple to put anywhere.  Useful if you are not in a position to
allocate a separate partition.</p>

<P>The directory can not be mounted at boot because the password is
not anywhere on the machine.  Services that depend on this directory
should not start at boot.  We generate a script
(called <code>mailboot</code> for our mailserver) that prompts for the
password, mounts the directory, then starts the services.  After a
reboot, ssh in and run this script.</p>

<p>We keep the mail spool, mail user database, DKIM keys, and sieve
files in this directory.  The mail queue is in there when using LUKS
(EncFS probably wouldn't work with the sockets in the postfix chroot).
Web data is not there because that is public information and we want
the web server to come up at boot.</p>

<p>This role is a dependency for the <code>mailhost</code> role.  You
can add it to the playbook for other machines, if, for example, you
wanted to keep your bacula pools in an encrypted directory.</p>

<!-- ============================== -->
<H2 class=rule>
<A NAME=cryptdir_vars></A>Disk Encryption Variables</H2>

<p>You must set the password, usually through the
<code>vault_cryptdir_pw</code> value in the hosts.example.
Set <code>cryptdir_type</code> to 'encfs', 'luks', or 'none' to change
the technology.  The default is EncFS and does not need any other
settings.</p>

<PRE class=code>
# EncFS encryption, no other settings needed.
# Data in /vault, ciphertext version in /vault_crypt
</PRE>

<p>
With LUKS, you must set <code>cryptdir_luks_dev</code> to the
partition for your encrypted data. LUKS encryption <b>completely
overwrites that partition</b>, so make sure that you don't have
anything important there!</p>

<PRE class=code>
# LUKS encryption, must specify partition
# Data in /vault
# Cleartext block device /dev/mapper/vault-blk
# Ciphertext block device /dev/replace-with-real-device

cryptdir_type: luks
cryptdir_luks_dev: "/dev/replace-with-real-device"
</PRE>

<p>You can turn off encryption if you have reasons.</p>

<PRE class=code>
# None, /vault unencrypted
cryptdir_type: none
</PRE>

<p>The name of the central directory is given
by <code>cryptdir_root</code>.  This defaults to <code>/vault</code>.


<!-- ============================== -->
<H2 class=rule>
<A NAME=why></A>Why These Packages?</H2>

<p>Any cert can enable encrypted communication, even a self-signed
one, but only a cert from a trusted certificate authority (CA) makes a
statement about your identity.  LetsEncrypt is the baseline that
states that you control a particular domain.  Other paid options can
be used if you need a stronger declaration of identity.  For simple
HTTPS and IMAPS, LetsEncrypt is fine.</p>

<p>A <a href="https://en.wikipedia.org/wiki/Virtual_private_server">virtual
private server</a> (VPS) in the cloud will never be as private as your
own machine.  The cloud company must access the hardware and disk
resources to manage their operations.  The disks could be mounted by
others, which is exactly how some cloud providers implement their
backup services.  If you encrypt the data on disk, it doesn't matter
who can look at it.</p>

<p>You can set up a VPS with an encrypted boot disk, but it requires a
fair bit more effort, and then you need something like dropbear to ssh
in at boot time and unlock the root partition.  If you go this route,
and manage it with Ansible, I'd like to see how you do it.</p>

<p>We take an intermediate path by putting private things (mail spool,
mail user database, keys) into one encrypted location.  At boot,
everything starts normally except mail, which waits until we log in
and unlock the directory.  Any incoming mail should remain queued by
the sending system until the mail daemon is up again.</p>

<p>The encryption depends on your situation.  If you can create
partitions, use LUKS, otherwise EncFS.  If you have physical control
of your server, you might choose 'none'.</p>

<p>LUKS uses a separate disk partition that is encrypted at the block
level, then mounted as cleartext block device through the mapper.  The
cleartext block device is then given a plain Ext4 filesystem and
mounted normally.</p>

<p>With EncFS, a separate directory containing individually encrypted
files is mounted loopback as cleartext through FUSE.  EncFS can be
used anywhere, but it is rather outdated, as is eCryptfs.  It works at
the file level, so it is not entirely transparent.</p>

<p>Another possibility is per-directory ext4 encryption with fscrypt.
I don't have much experience with that, but it might do a better job
than EncFS without needing a separate partition.</p>

<figure>
<img src="images/sun2.jpg" alt="Sun 2/170 CPU">
<figcaption>Encryption can be demanding.  You may need to overclock
the 68010 in your Sun 2/170 beyond 10mhz to keep up.
</figcaption>
</figure>

<div class=copyright>
<p>Copyright &copy; 2020 David Loffredo, licensed under
<a rel="license" href="https://creativecommons.org/licenses/by/4.0/">
CC BY 4.0</a>.
</p>
</div>
</div>
</body>
</html>
