<!DOCTYPE html>
<html lang="en">
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">

<title>Firewall</title>
<link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>
<div class=toc>
<UL>
<LI><A href=index.html>[home]</A>

<li><a href="#vars">Variables</a>
<li><a href="#why">Why These Packages?</a>
</UL>
</div>

<div class=main>
<H1>Firewall</H1>

<p><b>ROLE</b> common, firewall.yml

<p>We implement firewall rules directly using <code>iptables</code>,
with <code>iptables-persistent</code> to reload the configuration on
boot.  The IPv4 and IPv6 rules are in
<code>/etc/iptables/rules.v4</code> and <code>rules.v6</code>.  These
files are well commented and explain the purpose of each rule.</p>

<p>The IPv4 and IPv6 rules protect normal applications and those in
Docker containers.  We only allow incoming connections to ports that
were explicitly opened.  We always open the ssh port.  We also allow
pings, but rate limit them, and drop unusually-formed packets.</p>

<p>We run <code>fail2ban</code> to scan the logs for repeated
intrusion attempts and temporarily ban IPs.  We use a fairly
aggressive setting which may trip when trying to configure mail
clients.  You may want to use the <code>fail2ban-client</code> tool to
check the jails if you are having trouble connecting.</p>

<!-- ============================== -->
<H2 class=rule>
<A NAME=vars></A>Variables</H2>

<p>Open ports for new services by adding the symbolic name to
the <code>firewall_services</code> list.  It recongizes 'ssh', 'mail',
'web', 'dns', and 'bacula'.  You define your own names for services by
defining variables <code>&lt;name&gt;_opentcp</code>
and/or <code>&lt;name&gt;_openudp</code> as a list of port numbers.
It doesn't matter if port numbers are repeated across services.</p>

<PRE class=code>
firewall_services: [ 'ssh' ]

# Define 'foobar' name for firewall services by defining:
#foobar_opentcp: [ 12345, 23456 ]
#foobar_openudp: [ 34567 ]
</PRE>

<p>The <code>firewall_opentcp</code> and <code>firewall_openudp</code>
variables are just lists of extra ports that will be opened.</p>

<PRE class=code>
# will append ports from the mnemonic list of services but can be
# initialized with extra ports.
firewall_opentcp: []
firewall_openudp: []
</PRE>

<p>If you want to drop all connections from certain IPs, or allow all
connections from others, add them to the following lists.</p>
  
<PRE class=code>
# Friendly networks that should be ignored by fail2ban, and allowed
# through the firewall
firewall_allow_ips: []
firewall_allow_ips_v6: []
firewall_block_ips: []
firewall_block_ips_v6: []
</PRE>

<p>The firewall services names are used to set up jails for sshd,
dovecot, postfix and others depending on what names are present.
These are expanded to a list of hashes describing each jail. Each jail
hash has a "name" value that matches the key of the enclosing hash,
plus any other key/value pairs that should appear in the jail config
as "key = value".  You can also define jails for a named service in
a <code>fail2ban_jail_&lt;svc&gt;</code> variable.</p>

<PRE class=code>
fail2ban_jails: '{{ firewall_services }}'

# ssh jails always added
fail2ban_jail_ssh:
  - name: sshd
    mode: aggressive
  - name: pam-generic
    banaction: iptables-allports

fail2ban_jail_mail:
  - name: dovecot
  - name: postfix
  - name: postfix-sasl

fail2ban_jail_web:
  - name: apache-auth
  - name: apache-overflows
</PRE>

<p>By default, <code>fail2ban_jails</code> just uses the firewall
services list, but you can customize this and override the defaults by
adding your own hashes.  The last hash with a given name will be used.
The example below has the builtin ssh jails, the mail jails, an apache
jail that operates on the DOCKER-USER chain, and overides the sshd
jail with a very long ban.</p>

<PRE class=code>
fail2ban_jails:
  - mail
  - name: apache-auth
    chain: DOCKER-USER
  - name: sshd
    mode: aggressive
    bantime: 1000years
</PRE>


<!-- ============================== -->
<H2 class=rule>
<A NAME=docker></A>Docker</H2>

<p>Network traffic to software in Docker containers is handled
differently than traffic to software running natively on the machine.
Docker creates small virtual LANs to connect containers within the
machine.  Traffic going to a Docker container is then routed to this
virtual LAN through the iptables FORWARD chain, while traffic going to
native software is handled by the INPUT chain.</p>

<p>These chains are in the default "filter" table.  Unfortunately,
most people add their firewall rules to the INPUT chain, which has no
effect on traffic to Docker containers.  We do most of the blocking on
the PREROUTING chain of the "mangle" table.  Packets go through this
chain early in the processing, which has two big benefits.  First, it
covers both native apps and Docker containers.  Second, the earlier
you can drop a bad packet, the more bad packets you can handle.</p>

<p>We do need to make some accommodations for Docker.  In particular,
when using fail2ban for a container, we must make sure that it can
find the logs for the container and put its rules on the DOCKER-USER
chain.</p>


<!-- ============================== -->
<H2 class=rule>
<A NAME=why></A>Why These Packages?</H2>

<p>The <code>ufw</code> (universal firewall) package is a popular
choice for blocking everything except for a few ports, and it has a
convenient Ansible module.  It is nice for manually opening and
closing ports, but it is just a wrapper around <code>iptables</code>
and <code>iptables-save</code> files.</p>

<p>I generated <code>iptables-save</code> files directly because it
gives a much clearer picture of the complete state of the rules, while
UFW mostly just gets in the way if you want to use ipsets or work with
the sophisticated rules set up by Docker.  The iptables syntax is easy
enough to understand once you've seen a few rules.</p>

<p>A second reason was idempotency.  UFW keeps its
own <code>iptables-save</code> files, so a port stays open until you
explicitly tell UFW to close it.  With Ansible, we list open ports, so
when you remove a port from the list, you may intend it to be closed,
but it remains open on the machine until you tell UFW to close it.  By
generating the rules.v4 and rules.v6 ourselves, we guarantee a known
state.</p>

<p>It seems like some people are moving to nftables (nft) instead of
iptables.  Something to keep an eye on for the future.</p>

<p>Fail2ban helps a bit on password protected service like IMAP by
limiting the number of attempts an attacker can make before switching
IPs, but is more noise control for the logs than security.  The
version in Debian 10 is fairly recent so we use it stock.  The Debian
9 version was old, so we previously added some custom patterns for
ssh.</p>

<figure>
<img src="images/network.jpg" alt="10BASE-2 FTW">
<figcaption>One alternative to a firewall is to make your network so
unpleasant that attackers move on.  Mix in some thicknet or modems
with accoustic couplers if you can find them.
</figcaption>
</figure>

<div class=copyright>
<p>Copyright &copy; 2020 David Loffredo, licensed under
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/">
CC BY-SA 4.0</a>.
</p>
</div>
</div>
</body>
</html>
