<!DOCTYPE html>
<HTML>
<HEAD>
   <TITLE>Firewall</TITLE>
   <link rel="stylesheet" type="text/css" href="style.css">
</HEAD>
<BODY>
<div class=toc>
<UL>
<LI><A href=index.html>[home]</A>

<li><a href="#vars">Variables</a>
<li><a href="#why">Why These Packages?</a>
</UL>
</div>

<H1>Firewall</H1>

<p><b>ROLE</b> common, firewall.yml

<p>We implement firewall rules directly using <code>iptables</code>,
with <code>iptables-persistent</code> to reload our configuration on
boot.  The playbook writes our IPv4 and IPv6 rules to
<code>/etc/iptables/testrules.v4</code> and <code>testrules.v6</code>,
and then runs <code>iptables-restore</code>
and <code>iptables-save</code> to round-trip them into
the <code>rules.v4</code> and <code>rules.v6</code> files that are
loaded at boot.</p>

<p>The rules drop all incoming connections unless explicitly enabled
by the variables described below.  It allows pings, but rate limits
them, and also drops unusually-formed packets.  We always open the ssh
port.</p>

<p>We run <code>fail2ban</code> to scan the logs for repeated
intrusion attempts and temporarily ban IPs.

<!-- ============================== -->
<H2 class=rule>
<A NAME=vars></A>Variables</H2>

<p>Open ports for new services by adding the symbolic name to
the <code>firewall_services</code> list.  This is used by the iptables
and fail2ban tasks.  It recongizes 'ssh', 'mail', 'web', 'dns', and
'bacula'.  You define your own names for services by defining
<code>&lt;name&gt;_opentcp</code>
and/or <code>&lt;name&gt;_openudp</code> as a list of port numbers.
It doesn't matter if port numbers are repeated across services.

<PRE class=code>
firewall_services: [ 'ssh' ]

# Define 'foobar' name for firewall services by defining:
#foobar_opentcp: [ 12345, 23456 ]
#foobar_openudp: [ 34567 ]
</PRE>

<p>The <code>firewall_opentcp</code> and <code>firewall_openudp</code>
variables are just lists of extra ports that will be opened.

<PRE class=code>
# will append ports from the mnemonic list of services but can be
# initialized with extra ports.
firewall_opentcp: []
firewall_openudp: []
</PRE>

<p>If you want to drop all connections from certain IPs, add them to the
<code>firewall_blacklist_ips</code> list.
  
<PRE class=code>
# blocked if defined
firewall_blacklist_ips: []
</PRE>



<!-- ============================== -->
<H2 class=rule>
<A NAME=why></A>Why These Packages?</H2>

<p>The <code>ufw</code> (universal firewall) front end is very popular
because it makes it easy to block everything and open up a few ports.
It also has a convenient Ansible module.  It is very good if you are
manually managing the ports, but it is just a wrapper
around <code>iptables</code>.

<p>I decided to use <code>iptables</code> directly for two reasons.
First, it seemed that UFW took over everything, so it was not possible
to integrate with other tools like ipsets.  However, a closer read of
the docs shows that it just manages iptables-save files
in <code>/etc/ufw</code>, so we could add things there.

<p>The second reason was idempotency.  UFW remembers state, so if a
port is open, you must explicitly tell it to close if you want it
closed.  With Ansible, we are just adding and removing ports from a
variable so you must reset ufw every playbook run.  That makes it
appear that the state changed even when it did not.  Our current
iptables task is totally idempotent.

<p>Fail2ban helps a bit on password protected service like IMAP by
limiting the number of attempts an attacker can make before switching
IPs, but is more noise control for the logs than security.

Debian 10 has a fairly recent package so we use it stock and
enable checks for sshd, dovecot, postfix and a few others depending on
what services are present.  The version in Debian 9 was old, so we
previously added some custom patterns for ssh.

</BODY>
</HTML>
