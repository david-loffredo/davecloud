<!DOCTYPE html>
<HTML>
<HEAD>
   <TITLE>Firewall</TITLE>
   <link rel="stylesheet" type="text/css" href="style.css">
</HEAD>
<BODY>
<div class=toc>
<UL>
<LI><A href=index.html>[home]</A>

<li><a href="#vars">Variables</a>
<li><a href="#why">Why I Chose These Packages</a>
</UL>
</div>

<H1>Firewall</H1>

<p><b>ROLE</b> common, firewall.yml

<p>We implement firewall rules directly using <code>iptables</code>,
with <code>iptables-persistent</code> to reload our configuration on
boot.  The playbook writes our IPv4 and IPv6 rules to
<code>/etc/iptables/testrules.v4</code> and <code>testrules.v6</code>,
and then runs <code>iptables-restore</code>
and <code>iptables-save</code> to round-trip them into
the <code>rules.v4</code> and <code>rules.v6</code> files that are
loaded at boot.  The rules drop most things unless explicitly enabled
based on the variables described below.  We always open the ssh port.

<p>We run <code>fail2ban</code> to scan the logs for repeated
intrusion attempts and temporarily ban IPs.   

<!-- ============================== -->
<H2 class=rule>
<A NAME=vars></A>Variables</H2>

<p>Open ports for new services by setting 'firewall_services'.  This
is checked by the iptables and fail2ban tasks.  It recongizes ssh,
mail, web, and dns, but you can add your own names to this list.  For
each element, we add &lt;name&gt;_opentcp and &lt;name&gt;_openudp, if
they exist, to the open ports.  Define &lt;name&gt;_opentcp/udp as a
list of ports.
<PRE class=code>
firewall_services: [ 'ssh' ]

# will append ports from the mnemonic list of services but can be
# initialized with extra ports.
firewall_opentcp: []
firewall_openudp: []
  
# blocked if defined
firewall_blacklist_ips: []
</PRE>



<!-- ============================== -->
<H2 class=rule>
<A NAME=why></A>Why I Chose These Packages</H2>

<p>The <code>ufw</code> (universal firewall) front end is very popular
because it makes it easy to block everything and open up a few ports.
It also has a convenient Ansible module.  It is very good if you are
manually managing the ports, but it is just a wrapper
around <code>iptables</code>.

<p>I decided to use <code>iptables</code> directly for two reasons.
First, it seemed that UFW took over everything, so it was not possible
to integrate with other tools like ipsets.  However, a closer read of
the docs shows that it just manages iptables-save files
in <code>/etc/ufw</code>, so we could add things there.

<p>The second reason was idempotency.  UFW remembers state, so if a
port is open, you must explicitly tell it to close if you want it
closed.  With Ansible, we are just adding and removing ports from a
variable so you must reset ufw every playbook run.  That makes it
appear that the state changed even when it did not.  Our current
iptables task is totally idempotent.

<p>Fail2ban helps a bit on password protected service like IMAP by
limiting the number of attempts an attacker can make before switching
IPs, but is more noise control for the logs than security.

Debian 10 has a fairly recent package so we use it stock and
enable checks for sshd, dovecot, postfix and a few others depending on
what services are present.  The version in Debian 9 was old, so we
previously added some custom patterns for ssh.

</BODY>
</HTML>
