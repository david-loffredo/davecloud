<!DOCTYPE html>
<html lang="en">
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">

<title>Firewall</title>
<link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>
<div class=toc>
<UL>
<LI><A href=index.html>[home]</A>

<li><a href="#vars">Variables</a>
<li><a href="#why">Why These Packages?</a>
</UL>
</div>

<div class=main>
<H1>Firewall</H1>

<p><b>ROLE</b> common, firewall.yml

<p>We implement firewall rules directly using <code>iptables</code>,
with <code>iptables-persistent</code> to reload our configuration on
boot.  The playbook writes IPv4 and IPv6 rules to the
<code>/etc/iptables/rules.v4</code> and <code>rules.v6</code> files
that are loaded at boot.  These files are well commented and explain
the purpose of each of the rules.</p>

<p>The IPv4 and IPv6 rules protect normal applications and those in
Docker containers.  We only allow incoming connections to ports that
were explicitly opened.  We always open the ssh port.  We also allow
pings, but rate limit them, and drop unusually-formed packets.</p>

<p>We run <code>fail2ban</code> to scan the logs for repeated
intrusion attempts and temporarily ban IPs.  We use a fairly
aggressive setting which may trip when trying to configure mail
clients.  You may want to use the <code>fail2ban-client</code> tool to
check the jails if you are having trouble connecting.</p>

<!-- ============================== -->
<H2 class=rule>
<A NAME=vars></A>Variables</H2>

<p>Open ports for new services by adding the symbolic name to
the <code>firewall_services</code> list.  It recongizes 'ssh', 'mail',
'web', 'dns', and 'bacula'.  You define your own names for services by
defining
<code>&lt;name&gt;_opentcp</code>
and/or <code>&lt;name&gt;_openudp</code> as a list of port numbers.
It doesn't matter if port numbers are repeated across services.  The
fail2ban setup also uses these names and sets up jails for sshd,
dovecot, postfix and a few others depending on what names are
present.</p>


<PRE class=code>
firewall_services: [ 'ssh' ]

# Define 'foobar' name for firewall services by defining:
#foobar_opentcp: [ 12345, 23456 ]
#foobar_openudp: [ 34567 ]
</PRE>

<p>The <code>firewall_opentcp</code> and <code>firewall_openudp</code>
variables are just lists of extra ports that will be opened.</p>

<PRE class=code>
# will append ports from the mnemonic list of services but can be
# initialized with extra ports.
firewall_opentcp: []
firewall_openudp: []
</PRE>

<p>If you want to drop all connections from certain IPs, add them to the
<code>firewall_blacklist_ips</code> list.</p>
  
<PRE class=code>
# blocked if defined
firewall_blacklist_ips: []
</PRE>

<!-- ============================== -->
<H2 class=rule>
<A NAME=docker></A>Docker</H2>

<p>Network traffic to software in Docker containers is handled
differently than traffic to software running natively on the machine.
Docker creates small virtual LANs to connect containers within the
machine.  Traffic going to a Docker container is then routed to this
virtual LAN through the iptables FORWARD chain, while traffic going to
native software is handled by the INPUT chain.</p>

<p>These chains are in the default "filter" table.  Unfortunately,
most people add their firewall rules to the INPUT chain, which has no
effect on traffic to Docker containers.  We do most of the blocking on
the PREROUTING chain of the "mangle" table.  Packets go through this
chain early in the processing, which has two big benefits.  First, it
covers both native apps and Docker containers.  Second, the earlier
you can drop a bad packet, the more bad packets you can handle.</p>

<p>We do need to make some accommodations for Docker.  In particular,
when using fail2ban for a container, we must make sure that it can
find the logs for the container and put its rules on the DOCKER-USER
chain.</p>


<!-- ============================== -->
<H2 class=rule>
<A NAME=why></A>Why These Packages?</H2>

<p>The <code>ufw</code> (universal firewall) package is a popular
choice for blocking everything except for a few ports, and it has a
convenient Ansible module.  It is nice for manually opening and
closing ports, but it is just a wrapper around <code>iptables</code>
and <code>iptables-save</code> files.</p>

<p>I generated <code>iptables-save</code> files directly because it
gives a much clearer picture of the complete state of the rules, while
UFW mostly just gets in the way if you want to use ipsets or work with
the sophisticated rules set up by Docker.  The iptables syntax is easy
enough to understand once you've seen a few rules.</p>

<p>A second reason was idempotency.  UFW keeps its
own <code>iptables-save</code> files, so a port stays open until you
explicitly tell UFW to close it.  With Ansible, we list open ports, so
when you remove a port from the list, you may intend it to be closed,
but it remains open on the machine until you tell UFW to close it.  By
generating the rules.v4 and rules.v6 ourselves, we guarantee a known
state.</p>

<p>It seems like some people are moving to nftables (nft) instead of
iptables.  Something to keep an eye on for the future.</p>

<p>Fail2ban helps a bit on password protected service like IMAP by
limiting the number of attempts an attacker can make before switching
IPs, but is more noise control for the logs than security.  The
version in Debian 10 is fairly recent so we use it stock.  The Debian
9 version was old, so we previously added some custom patterns for
ssh.</p>

<figure>
<img src="images/network.jpg" alt="10BASE-2 FTW">
<figcaption>One alternative to a firewall is to make your network so
unpleasant that attackers move on.  Mix in some thicknet or modems
with accoustic couplers if you can find them.
</figcaption>
</figure>

<div class=copyright>
<p>Copyright &copy; 2020 David Loffredo, licensed under
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/">
CC BY-SA 4.0</a>.
</p>
</div>
</div>
</body>
</html>
